[
  {
    "objectID": "blog.html",
    "href": "blog.html",
    "title": "E155 Blog",
    "section": "",
    "text": "Intial Reflection\n\n\nInital Refelection and Goals for my semester in MicroPs\n\n\n\n\n\nAug 24, 2025\n\n\nSadhvi Narayanan\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "E155 Portfolio",
    "section": "",
    "text": "Sadhvi Narayanan is a junior at Harvey Mudd College. She is majoring in CS, but is also interested in Computer Engineering which is why she is taking MicroProcessors. In her free time she enjoys baking, watching tv shows, spending time outdoors, and convincing herself to go for runs (but she never actually executes them).\nEmail: sanarayanan@g.hmc.edu"
  },
  {
    "objectID": "posts/initial_reflection/first-post.html",
    "href": "posts/initial_reflection/first-post.html",
    "title": "Intial Reflection",
    "section": "",
    "text": "Hello Everyone! This is my first blog post on my intial reflections and goals I have for this semester with MicroPs. I am excited to work with microprocessors to build various projects throughout the semester.\nSome of my goals for this semester include:\n\nBuild a good understanding of embedded systems: I want to get comfortable reading datasheets, working with GPIOs, and understanding how microcontrollers interact with external hardware. I also want to understand how different systems can be connected and can communicate with each other in a synchronus way.\nBuild confidence in programming microcontrollers: I want to get more experience in writing the code to interact with microcontrollers effectively, and be able to control various aspects of it through software. I also want to sharpen my debugging skills.\nImprove my design thought-process: I want to be thoughtful with the way I design and craft my project to make sure it is optimal and scalable.\nConnect learnings and labs to real-world applications: I want to use whatever we learn and build through this class to connect it to applications outside, and build better intuition for how some complex systems work.\nCollaborate with classmates: I know some projects can be challenging and require a team effort, so I want to get to know other classmates and collaborate with them throughout the course.\nBuild a cool final projcet: I hope to use all the skills we’ve picked up along the way, and other learning we’ve encountered to build a cool, novel, exciting final project that I am really proud of!\nMake sure I understand all the concepts: I want to make sure I understand everything that is being taught, and reach out in case something is unclear to me, or if I have any doubts."
  },
  {
    "objectID": "labs/lab1/lab1.html",
    "href": "labs/lab1/lab1.html",
    "title": "Lab 1 Report",
    "section": "",
    "text": "In this lab, we built out motherboard with the FPGA and the microcontroller through soldering, and tested our board by loading designs onto our FPGA nad microcontroller. We implemented a design on the FPGA to test the on-board high-speed oscillator by blinking one of the on-board LEDs. And we implemented a program on the microcontroller to light an LED.\nOverall, the main goal after creating our boards was to create a seven segment display. We wrote verilog to convert a 4-bit hex inputted through a switch into display using 7-segments. We did this by programming pins on the FPGA based on the switches, and then connecting this to a physical build of a seven-segment display on a breadboard to observe the numbers. We also used the switches to light other LEDs on the FPGA, and like described earlier, we used the on-board high-speed oscillator to blind an on-board led at 2.4Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#introduction",
    "href": "labs/lab1/lab1.html#introduction",
    "title": "Lab 1 Report",
    "section": "",
    "text": "In this lab, we built out motherboard with the FPGA and the microcontroller through soldering, and tested our board by loading designs onto our FPGA nad microcontroller. We implemented a design on the FPGA to test the on-board high-speed oscillator by blinking one of the on-board LEDs. And we implemented a program on the microcontroller to light an LED.\nOverall, the main goal after creating our boards was to create a seven segment display. We wrote verilog to convert a 4-bit hex inputted through a switch into display using 7-segments. We did this by programming pins on the FPGA based on the switches, and then connecting this to a physical build of a seven-segment display on a breadboard to observe the numbers. We also used the switches to light other LEDs on the FPGA, and like described earlier, we used the on-board high-speed oscillator to blind an on-board led at 2.4Hz."
  },
  {
    "objectID": "labs/lab1/lab1.html#design-and-testing-methodology",
    "href": "labs/lab1/lab1.html#design-and-testing-methodology",
    "title": "Lab 1 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThere were two different steps associated with the hardware component of the design, with the first one being the soldering of the components.\nThere were two main parts to soldering the components to the motherboard - we had to solder on the SMD components, and the THT components as well. We also soldered on the FPGA and micro-controller as well.\nAfter the soldering was done, we proceeded to test our board. We first loaded a test program to the FPGA which uses the high-speed oscillator (HSOSC) from the iCE40 UltraPlus primitve library. Here, this library is used to generate a clock signal at 24Mhz, and then counter was implemented in order to produce a blinking frequency of 1.5Hz, so that we could see it on the LEDs. This was developed with a clock-divider module. After this, we uploaded another program to our FPGA which toggles pin P25 at around 1Hz, and if switch SW7 is on, then P25 is connected to PA9 which will see LED D3 blinking. We then, uploaded a program to our MCU unit, which reads the value of the toggled LED from the FPGA and echoes it to another pin which then causes LED D2 blinking.\nWe then implemented the 7-segment code in verilog, which was essetially a decoder. Along with this, we programmed some switch inputs to control 3 other on-board FPGA LEDs using combinational logic, and using the HSOSC to take teh 24MHz signal and convert it into a 2.4Hz signal which was reflected in a blinking LED. I then used an oscilliscope to test the frequency of the blinking LED and it was exactly 2.4Hz. Figure 1 below shows this.\n\n\n\nFigure 1: Oscilliscope Trace showing the 2.4Hz signal on the bottom right\n\n\nAfter this, we had to build the 7-segment LED display on a breadboard. After looking at the specs, I was able to apply power to one of the middle pins on either side, and ground the respective other pins in order to turn on that respective segment. Each non-power pin on the displaywas then hooked to ground through a 10kohm resistor. I made sure to connect the programmed pins from the FPGA to the seven-segment display. In order to test this, I created a self-checking testbench which ran through all posisble inputs and made sure the outputs were as expected."
  },
  {
    "objectID": "labs/lab1/lab1.html#technical-documentation",
    "href": "labs/lab1/lab1.html#technical-documentation",
    "title": "Lab 1 Report",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe source code for the project can be found in the associated Github repository\n\nBlock Diagram\n The block diagram in Figure 2 demonstrates the overall design and architecture of the design. The top-level module incldes two sub-modules - the HSOSC (high-speed oscillator block), and the seven_segment module in order to convert hex digits to seven segments. Additionally, there is internal counter logic fro the clock divider, as well as combinational logic to control the LEDs.\n\n\nSchematic\n Figure 3 demonstrates the physical layout of the design. We have internal 100k-ohm pullup resistors in order to ensure the pins aren’t floating. We then have the output on-board LEDs connected using a 1k-ohm current limiting resistor to ensure the output current (around 2.6mA) did not exceed the maximum output current of the FPGA I/O pins.\n\n\n\nFigure 4: Current Calculations\n\n\nThen, if we look further down, we can see the seven-segment display component. Here we power the middle pin on the left, which propogates to all the other pins. In order to turn on a pin, it needs to be grounded, hence we have 10k-ohm resistors connected from each output pin to ground in order to not exceed the maximum allowed output current of the pins. Figure 4 highlights the calculations performed to ensure we were not exceeding the maximum current allowed."
  },
  {
    "objectID": "labs/lab1/lab1.html#results-and-discussion",
    "href": "labs/lab1/lab1.html#results-and-discussion",
    "title": "Lab 1 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\n\n\nFigure 5: A screenshot of a QuestaSim simulation demonstrating the hex-switch inputs and the correspinding seven segment output.\n\n\n\n\n\nFigure 6: A screenshot of a QuestaSim simulation demonstrating the toggling LED at 2.4Hz using the clock divder.\n\n\nI was able to accomplish all of the prescribed tasks in this project. I also met all the intended design objectives, and was able to check off all the components in the spec, along with the excellence components. Figure 5 shows a screenshot of the QuestaSim Simulation. This is the simulation run with the self checking test-bench.\nFigure 6 on the other hand, shows the toggling of led 2 at 2.4Hz using the clock divider. If I was given more time, I would have expanded the testbench to also test that the led signal was infact blinking at 2.4Hz through possibly another clock generation. The design performed exactly as intended, with the blinking LEDs blinking at the approproate frequencies, and the seven segment display working exactly as intended."
  },
  {
    "objectID": "labs/lab1/lab1.html#conclusion",
    "href": "labs/lab1/lab1.html#conclusion",
    "title": "Lab 1 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe overall design, after all the testing, successfully takes a 4-bit hex number inputted by the user on the DIP switches, and then converts this into the numeric hex representation of this number on the seven-segment display. I spent a total of 25 hours working on this lab."
  },
  {
    "objectID": "labs/lab1/lab1.html#ai-prototype-summary",
    "href": "labs/lab1/lab1.html#ai-prototype-summary",
    "title": "Lab 1 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\n\nFigure 7: Initial ChatGPT response\n\n\nFigure 7 shows the result of entering the prompt into ChatGPT.\nAfter entering this project into Lattice, and synthesiszing it, it seemed to have run with no errors, meaning at least the verilog syntax was correct. Additionally, it seems like most of the logic is correct for the counter, and it even accounted for dividing the period by 2 in order to toggle two times in each period. Figure 8 shows the successful response.\n\n\n\nFigure 8: Lattice Synthesis Result\n\n\nOverall, I would say that the quality of this verilog is really nice, with a very exact counter. This was similar to how I learned it in E85 last semester for my music lab, and therefore how I implemented it myself. The LLM did generate some constructs like parameter int, which I have never used before. The code did synthesize the first time around, which is impressive. However, this is also a common application of clock dividing, so it must have been trained on a lot of relevant data. There were very small errors such as bit truncation for optimization.\nNext time I use LLM in my workflow, it is important to understand how to prompt the model, it is important to give it the constraints you are working under, and even providing specific library names are important. I was really surprised when the LLM picked up on the HSOSC library and the documentation for the syntax."
  },
  {
    "objectID": "labs/lab2/lab2.html",
    "href": "labs/lab2/lab2.html",
    "title": "Lab 2 Report",
    "section": "",
    "text": "In this lab, we built a time-multiplexed seven segment display, which would share one single seven_segment decoder module, in order to display what looks like two numbers on the dual display at the same time. The module is a shared resource between both DIP-switch controlled numbers, so the overall goal was to time-multiplex the seven segment decoder to allow only one number to have access to the led display, but flash at a frequency fast enough to make it seem like both numbers were appearing at the same time (as though we had two different module instantiations). The numbers are controlled by two independent DIP switches.\nAdditionally, we have an LED that displays the sum of the numbers inputted in on both the DIP switches."
  },
  {
    "objectID": "labs/lab2/lab2.html#introduction",
    "href": "labs/lab2/lab2.html#introduction",
    "title": "Lab 2 Report",
    "section": "",
    "text": "In this lab, we built a time-multiplexed seven segment display, which would share one single seven_segment decoder module, in order to display what looks like two numbers on the dual display at the same time. The module is a shared resource between both DIP-switch controlled numbers, so the overall goal was to time-multiplex the seven segment decoder to allow only one number to have access to the led display, but flash at a frequency fast enough to make it seem like both numbers were appearing at the same time (as though we had two different module instantiations). The numbers are controlled by two independent DIP switches.\nAdditionally, we have an LED that displays the sum of the numbers inputted in on both the DIP switches."
  },
  {
    "objectID": "labs/lab2/lab2.html#design-and-testing-methodology",
    "href": "labs/lab2/lab2.html#design-and-testing-methodology",
    "title": "Lab 2 Report",
    "section": "Design and Testing Methodology",
    "text": "Design and Testing Methodology\nThere were various steps in implementing this lab. First, we could use the base code from lab 1, which was displaying a single DIP switches input into one seven segment LED display. But, for this lab, we created a clock which toggled at 60Hz from a clock divider - around the frequency of flicker free viewing for humans. Then, every 60Hz I would toggle a signal, which woudl essentially be the select signal for a mux which would decide which DIP switche’s input to display on the LED. Based on which DIP switch’s input was selected, that would be fed into the single, shared, seven segment module instantiation which would then display that number on the display. However, because we made our new clock toggle at 60Hz, the flicker free viewing frequency, both switch numbers are toggling so fast it looks like they are both displayed on the LED-display at the same time. Due to this, when building the circuit on the breadboard, I would only need 7 pins to connect to all the 14 different segments on the dual-display, because we designed it so that only 7 segments can be driven at a time, since there is only one seven segment module decoder. Additionally, the FPGA does not have enough power to drive the dual-segment LED display, so we had to connect the output of the FPGA pins to a PNP transistor which was connected to a 3.3V collecter, so everytime a high signal was asserted by any of the pins it would pull current from the collecter in order to provide enough power to the dual display. I had an enable signal that was two bits wide, and depending on the clock signal, would either provide a base to one of the two PNP transistors. And we also had 5 LEDs which would just display the sum of both the dip switches.\nIn order to test the design, I first isolated my clock divider module, so I could test that the clock was indeed running 60Hz. I created my own clock signal in the testbench, and then asserted that after 60Hz from the testbench, we were also toggling the clock in my clock module. Essentially, I made sure both clocks were running at the same frequency.\nThen, in order to test the rest of my design, I had another testbench. This time, I did not use testvectors, but rather leveraged assert statements. I generated a counter that was 8-bits wide, and each time it would split this 8-bit bus into two 4-bit busses, which would simulate the inputs on both by 4-input DIP switches. I then made sure the addition of the led signal was equal to the sum of both of 4-bit busses. And then, based on the enable signal asserted from my top-level module, I made sure that the actual seven-segment output, matched with the one I was chosing based on the enable signal and switch value.\nI made sure to calculate appropriate resistor values based on the maximum drivable current as well for all my pins.\n\n\n\nFigure 1: Image of the physical setup\n\n\nFigure 1 shows the physical implementation the breadboard with the time-multiplexed segment visible."
  },
  {
    "objectID": "labs/lab2/lab2.html#technical-documentation",
    "href": "labs/lab2/lab2.html#technical-documentation",
    "title": "Lab 2 Report",
    "section": "Technical Documentation:",
    "text": "Technical Documentation:\nThe source code for the project can be found in the associated Github repository\n\nBlock Diagram\n The block diagram in Figure 2 demonstrates the overall design and architecture of the design. The top-level module incldes three sub-modules - the HSOSC (high-speed oscillator block), the clock, and the seven_segment module in order to convert hex digits to seven segments. The clock is essentially the clock divider which is taking care of toggling the clock at 60Hz. We can see the internal logic of the muxes as well, in order to multiplex the values given to the seven-segment module, based on the generated clock.\n\n\nSchematic\n Figure 3 demonstrates the physical layout of the design. We have internal 100k-ohm pullup resistors in order to ensure the pins aren’t floating. We then have the DIP switch on the right connected to around a 420 ohm pull-down resistor on the left, and then power to the right. We have each of our PNP transistors connected to a 3.3V collecter, and a 330-ohm resistor in order to limit the current going into the transistor base. Each of our segments was connected to a pin, with two segments mapping to one pin due ot the shared seven-segment module. Each segment was connected to a 170 ohm resistor to limit the current going into the LED’s, while not exceeding the maximum current that can be driven by an FPGA pin. Our adder-sum LED’s are each connected to a 100ohm resistor to limit the current through the diodes to around 13mA, which is within its possible range.\n\n\n\nFigure 4: Current Calculations\n\n\nIn Figure 4 we can see all the calculations performed to ensure we are not drawing more current that possible from the FPGA pins - 8mA."
  },
  {
    "objectID": "labs/lab2/lab2.html#results-and-discussion",
    "href": "labs/lab2/lab2.html#results-and-discussion",
    "title": "Lab 2 Report",
    "section": "Results and Discussion",
    "text": "Results and Discussion\n\n\n\nFigure 5: A screenshot of a QuestaSim simulation demonstrating the clock toggling at the right frequency - 60Hz.\n\n\n\n\n\nFigure 6: A screenshot of a QuestaSim simulation for the top level module.\n\n\nI was able to accomplish all of the prescribed tasks in this project. I also met all the intended design objectives, and was able to check off all the components in the spec, along with the excellence components. Figure 5 shows a screenshot of the QuestaSim Simulation of the clock module. This is the simulation run with the self checking test-bench without testvectors. Figure 6 shows the testbench designed for the overall top-level design, which was also designed without testvectors and was instead an assert based testbench.\nIf I was given more time, I would have tried to come up with other ways to test the clock signal using the in-built delays available in the testbench. I would have also made my wires on my breadboard more concise and neater, so it would have been easier to debug. The design performed exactly as intended."
  },
  {
    "objectID": "labs/lab2/lab2.html#conclusion",
    "href": "labs/lab2/lab2.html#conclusion",
    "title": "Lab 2 Report",
    "section": "Conclusion",
    "text": "Conclusion\nThe overall design, after all the testing, successfully time-multiplexes the seven-segment decoder to ensure that is a shared resource between two possible inputs from two independent DIP switches. Although the dual display can only be used by one DIP switches output at a time, the fast multiplexing makes it seem like both numbers are being displayed at the same time - as our eyes are not able to detect the flicker. I spent a total of 12 hours working on this lab."
  },
  {
    "objectID": "labs/lab2/lab2.html#ai-prototype-summary",
    "href": "labs/lab2/lab2.html#ai-prototype-summary",
    "title": "Lab 2 Report",
    "section": "AI Prototype Summary",
    "text": "AI Prototype Summary\n\n\n\nFigure 7: Initial ChatGPT response\n\n\nFigure 7 shows the result of entering the prompt into ChatGPT.\nAfter entering this project into Lattice, and synthesiszing it, it seemed to have run with no errors, meaning at least the verilog syntax was correct. Additionally, it seems like most of the logic is correct for the counter, and it even accounted for dividing the period by 2 in order to toggle two times in each period. Figure 8 shows the successful response.\n\n\n\nFigure 8: Lattice Synthesis Result\n\n\nOverall, I would say that the quality of this verilog is really nice, with a very exact counter. This was similar to how I learned it in E85 last semester for my music lab, and therefore how I implemented it myself. The LLM did generate some constructs like parameter int, which I have never used before. The code did synthesize the first time around, which is impressive. However, this is also a common application of clock dividing, so it must have been trained on a lot of relevant data. There were very small errors such as bit truncation for optimization.\nNext time I use LLM in my workflow, it is important to understand how to prompt the model, it is important to give it the constraints you are working under, and even providing specific library names are important. I was really surprised when the LLM picked up on the HSOSC library and the documentation for the syntax."
  },
  {
    "objectID": "labs.html",
    "href": "labs.html",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab Report"
  },
  {
    "objectID": "labs.html#lab-1---board-assembly-and-testing",
    "href": "labs.html#lab-1---board-assembly-and-testing",
    "title": "E155 Labs",
    "section": "",
    "text": "Lab Report"
  },
  {
    "objectID": "labs.html#lab-2---multiplexed-7-segment-display",
    "href": "labs.html#lab-2---multiplexed-7-segment-display",
    "title": "E155 Labs",
    "section": "Lab 2 - Multiplexed 7-Segment Display",
    "text": "Lab 2 - Multiplexed 7-Segment Display\nLab Report"
  },
  {
    "objectID": "labs.html#lab-3---keypad-scanner",
    "href": "labs.html#lab-3---keypad-scanner",
    "title": "E155 Labs",
    "section": "Lab 3 - Keypad Scanner",
    "text": "Lab 3 - Keypad Scanner\nLab Report"
  },
  {
    "objectID": "labs.html#lab-4---digital-audio",
    "href": "labs.html#lab-4---digital-audio",
    "title": "E155 Labs",
    "section": "Lab 4 - Digital Audio",
    "text": "Lab 4 - Digital Audio\nLab Report"
  },
  {
    "objectID": "labs.html#lab-5---interrupts",
    "href": "labs.html#lab-5---interrupts",
    "title": "E155 Labs",
    "section": "Lab 5 - Interrupts",
    "text": "Lab 5 - Interrupts\nLab Report"
  },
  {
    "objectID": "labs.html#lab-6---the-internet-of-things-and-serial-peripheral-interface",
    "href": "labs.html#lab-6---the-internet-of-things-and-serial-peripheral-interface",
    "title": "E155 Labs",
    "section": "Lab 6 - The Internet of Things and Serial Peripheral Interface",
    "text": "Lab 6 - The Internet of Things and Serial Peripheral Interface\nLab Report"
  },
  {
    "objectID": "labs.html#lab-7---the-advanced-encryption-standard-aes",
    "href": "labs.html#lab-7---the-advanced-encryption-standard-aes",
    "title": "E155 Labs",
    "section": "Lab 7 - The Advanced Encryption Standard (AES)",
    "text": "Lab 7 - The Advanced Encryption Standard (AES)\nLab Report"
  },
  {
    "objectID": "resources.html",
    "href": "resources.html",
    "title": "E155 Resources",
    "section": "",
    "text": "These are the resources used in E155!\nLink to Course Website"
  }
]